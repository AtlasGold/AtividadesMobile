'use strict'

var base_types = ['Array', 'Boolean', 'Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp']
var methods = { Check, Scan }

module.exports = (obj) => {
    return new Keith(obj)
}

function Keith (obj) {
    this._errors = []
    if (Object.prototype.toString.call(obj) === '[object Object]') this._build = obj
}

Keith.prototype.check = check
Keith.prototype.scan = scan
Keith.prototype.errors = errors
Keith.prototype.build = build

function errors () {
    return this._errors.length ? this._errors : null
}

function build () {
    return this._build
}

function use (func) {
    this._callback = func

    return this
}

function scan (obj) {
    return new Scan(obj, this._errors, this._build)
}

function check (param, name) {
    return new Check(param, name, this._errors, this._build)
}

function interrupt (err, cb) {
    // if (cb) cb(err.message || err)

    // throw new assert.AssertionError({
    //     message: err,
    //     stackStartFunction: arguments.callee
    // })
}

function Check (param, name, errors, build) {
    this._param = param
    this._name = name
    this._errors = errors
    this._build = build
}

Check.prototype._interrupt = interrupt

Check.prototype.check = check
Check.prototype.scan = scan
Check.prototype.errors = errors
Check.prototype.build = build

Check.prototype.test = function (param, test_func) {
    let errored = false

    try {
        var result = test_func(param)
        var type = Object.prototype.toString.call(result)
    } catch (exc) {
        errored = true
        this._errors.push(exc.message)
    }

    if (type === '[object Error]' || type === '[object String]') {
        errored = true
        this._errors.push(result.message || result)
    }

    if (!errored && this._build && this._name) this._build[this._name] = param

    return this
}

Check.prototype.optional_test = function (param, test_func) {
    let errored = false

    try {
        var result = test_func(param)
        var type = Object.prototype.toString.call(result)
    } catch (exc) {
        errored = true
        this._errors.push(exc.message)
    }

    if (type === '[object Error]' || type === '[object String]') {
        errored = true
        this._errors.push(result.message || result)
    }

    if (!errored && this._build && this._name) this._build[this._name] = param

    return this
}

function Scan (obj, errors, build) {
    this._obj = obj
    this._errors = errors
    this._build = build
}

Scan.prototype._interrupt = interrupt

Scan.prototype.check = check
Scan.prototype.scan = scan
Scan.prototype.errors = errors
Scan.prototype.build = build

Scan.prototype._get_key = function (full_key, obj) {
    if (typeof full_key === 'string') {
        full_key = full_key.split('.')
    }

    if (full_key.length === 0) {
        return {error: 'Invalid key to check given'}
    }

    var key = full_key.shift()

    if (obj !== new Object(obj) || !(key in obj)) {
        return {error: 'Key "' + key + '" does not exist'}
    }

    if (full_key.length >= 1) {
        return this._get_key(full_key, obj[key])
    }

    return {value: obj[key]}
}

Scan.prototype.test = function (key, test_func) {
    let errored = false

    let res = this._get_key(key, this._obj)
    
    if (res.error) {
        errored = true
        this._errors.push(res.error)
    }

    try {
        var result = test_func(key, res.value)
        var type = Object.prototype.toString.call(result)
    } catch (exc) {
        errored = true
        this._errors.push(exc.message)
    }

    if (type === '[object Error]' || type === '[object String]') {
        errored = true
        this._errors.push(result.message || result)
    }

    if (!errored && this._build) this._build[key] = this._obj[key]

    return this
}

Scan.prototype.optional_test = function (key, test_func) {
    var res = this._get_key(key, this._obj)
    if (res.error) return this

    let errored = false

    try {
        var result = test_func(key, res.value)
        var type = Object.prototype.toString.call(result)
    } catch (exc) {
        errored = true
        this._errors.push(exc.message)
    }

    if (type === '[object Error]' || type === '[object String]') {
        errored = true
        this._errors.push(result.message || result)
    }

    if (!errored && this._build) this._build[key] = this._obj[key]

    return this
}

base_types.forEach(function (type) {
    Scan.prototype['has' + type] = function (key) {
        return this.test(key, function (key, val) {
            if (Object.prototype.toString.call(val) !== '[object ' + type + ']') {
                return 'Key "' + key + '" should be a ' + type.toLowerCase() + '.'
            }

            return
        })
    }

    Check.prototype['is' + type] = function (param) {
        let name = this._name

        return this.test(this._param, function (param) {
            if (Object.prototype.toString.call(param) !== '[object ' + type + ']') {
                return (name ? '"' + name + '"' : 'Parameter') + ' is not a ' + type.toLowerCase() + '.'
            }

            return
        })
    }

    Scan.prototype['hasOptional' + type] = function (key) {
        return this.optional_test(key, function (key, val) {
            if (Object.prototype.toString.call(val) !== '[object ' + type + ']') {
                return 'Key "' + key + '" should be a ' + type.toLowerCase() + '.'
            }

            return
        })
    }

    Check.prototype['isOptional' + type] = function (param) {
        return this.optional_test(this._param, function (param) {
            if (Object.prototype.toString.call(param) !== '[object ' + type + ']') {
                return 'Parameter is not a ' + type.toLowerCase() + '.'
            }

            return
        })
    }
})

Object.keys(methods).forEach(function (method) {
    methods[method].prototype.isValidPassword = function (param) {
        return this.test(this._param, function (param) {
            if (Object.prototype.toString.call(param) !== '[object String]') {
                return 'Password is not a string.'
            }

            if (param.length < 8) {
                return 'Password is under 8 characters.'
            }

            return
        })
    }
})