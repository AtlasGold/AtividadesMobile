# Keith

An extendable tool used for basic data validation that doesn't force you into a specific debugging path.

# Installation

Simply use `npm` to install `keith`!

```javascript
npm install keith
```

# Supported Checks

`keith` supports all _basic_ data validation; we'll be adding options to extend its functionality soon.

Currently, that list consists of the following:

```javascript
.check(...)
    .isArray()
    .isBoolean()
    .isArguments()
    .isFunction()
    .isString()
    .isNumber()
    .isDate()
    .isRegExp()
    
.scan(...)
    .hasArray()
    .hasOptionalArray()
    .hasBoolean()
    .hasOptionalBoolean()
    .hasArguments()
    .hasOptionalArguments()
    .hasFunction()
    .hasOptionalFunction()
    .hasString()
    .hasOptionalString()
    .hasNumber()
    .hasOptionalNumber()
    .hasDate()
    .hasOptionalDate()
    .hasRegExp()
    .hasOptionalRegExp()
```

# Usage

In its basic form, `keith` wil check parameters given to it and return a list of issues.

In this case, everything's fine.

```javascript
const keith = require('keith')

let foo = 'I am a string.'
let errors = keith().check(foo).isString().errors()

console.log(errors)
// null
```

But if we change the value of `foo`:

```javascript
let foo = false
let errors = keith().check(foo).isString().errors()

console.log(errors)
// [ 'Parameter is not a string.' ]
```

We can also provide names to our singularly-checked variables for prettier messages:

```javascript
let errors = keith().check(foo, 'foo').isString().errors()

console.log(errors)
// [ '"foo" is not a string.' ]
```

Keith can keep checking as many parameters as you want:

```javascript
let foo = 'I am a string'
let bar = true
let baz = 24
let qux = {one: 'two'}

let errors = keith()
    .check(foo, 'foo').isNumber()
    .check(bar, 'bar').isBoolean()
    .check(baz, 'baz').isString()
    .check(qux, 'qux').isArray()
    .errors()
    
console.log(errors)
/* [ '"foo" is not a number.',
     '"baz" is not a string.',
     '"qux" is not a array.' ] */
```

You can scan through objects (and nested objects) with `keith` too, even in the same chain as individual checks:

```javascript
let args = {
    username: 'john',
    email: 'john@doe.net',
    gender: 'male',
    age: 24,
    
    location: {
        place: 'London'
    }
}

let yarn = false

let errors = keith()
    .scan(args)
        .hasString('username')
        .hasString('email')
        .hasString('gender')
        .hasNumber('age')
        .hasDate('dob')
        .hasString('location.place')
    .check(yarn, 'Yarn').isString()
    .errors()
    
console.log(errors)
/* [ 'Key "dob" does not exist.',
     'Key "dob" should be a date.',
     '"Yarn" is not a string.' ] */
```

Optional checks are also available when scanning objects, meaning validation will be applied if a key exists, otherwise will be ignored:

```javascript
let args = {
    username: 'john',
    bio: false
}

let errors = keith()
    .scan(args)
        .hasString('username')
        .hasOptionalString('bio')
        .hasOptionalString('email')
    .errors()
    
console.log(errors)
// [ 'Key "bio" should be a string.' ]
```

`keith` can even build an object for you as you parse parameters. Simply pass either a blank object or an object of defaults into the `keith()` call:

```javascript
let args = {
    username: 'john',
    email: 'john@doe.net',
    gender: 'male',
    age: 24,
    llamas: true
}

let checker = keith({
    service: 'Google'
}).scan(args)
    .hasString('username')
    .hasOptionalNumber('age')
    .hasOptionalString('bio')

console.log(checker.errors())
// null

console.log(checker.build())
// {service: 'Google', username: 'john', age: 24}
```